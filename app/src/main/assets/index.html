<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sanskrit Flashcards</title>
    <style>
        :root {
            --body-background: #333a45;
            --card-front-background: #e9f5fe; /* Light blue for front */
            --card-back-background: #fffada;  /* Light yellow for back */
            --card-border: #cce7f8;
            --text-color: #333;
            --stats-text-color: #f0f0f0;
            --accent-color: #007bff;
            --correct-color-value: #28a745;
            --wrong-color-value: #dc3545;
            --button-text-color: #fff;
        }
        * {
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: var(--body-background);
            color: var(--stats-text-color);
            padding: 10px;
            overflow: hidden;
        }
        .app-container {
            width: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .stats-bar {
            width: 100%;
            padding: 10px 0;
            text-align: center;
            font-size: 1.1em;
            color: var(--stats-text-color);
            margin-bottom: 20px;
            white-space: nowrap;
            overflow-x: auto;
        }
        .stats-bar span {
            margin: 0 5px;
        }
        .stat-value {
            font-weight: bold;
        }
        .stat-correct-value {
            color: var(--correct-color-value);
        }
        .stat-wrong-value {
            color: var(--wrong-color-value);
        }
        .stat-completion-value {
            color: var(--accent-color);
        }

        .flashcard-container {
            perspective: 1000px;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative; /* Needed for absolute positioning of swipe-feedback-overlay */
        }
        .flashcard {
            width: 90%;
            max-width: 400px;
            min-height: 280px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            cursor: pointer;
            border-radius: 12px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.2);
        }
        .flashcard.is-flipped {
            transform: rotateY(180deg);
        }
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            border-radius: 12px;
            background-color: var(--card-front-background);
            border: 1px solid var(--card-border);
            text-align: center;
            color: var(--text-color);
        }
        .card-front { }
        .card-back {
            transform: rotateY(180deg);
            background-color: var(--card-back-background);
        }
        .sanskrit-word {
            font-size: 2.6em;
            margin-bottom: 10px;
            word-break: break-word;
        }
        .pronunciation {
            font-size: 1.0em;
            line-height: 1.4;
            margin-bottom: 5px;
        }
        .pronunciation:last-of-type {
            margin-bottom: 10px;
        }
        .english-meaning {
            font-size: 1.8em;
            word-break: break-word;
        }
        .card-counter {
            font-size: 0.85em;
            color: #666;
            position: absolute;
            bottom: 10px;
            left: 0;
            right: 0;
            text-align: center;
        }

        .controls {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            margin-top: 25px;
            flex-shrink: 0;
        }
        .controls button {
            padding: 10px 15px;
            font-size: 1em;
            background-color: var(--accent-color);
            color: var(--button-text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            min-width: 90px;
            text-align: center;
            transition: background-color 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .controls button.reset-button {
            background-color: #6c757d;
        }
        .controls button.reset-button:hover {
            background-color: #5a6268;
        }
        .controls button:disabled {
            background-color: #777;
            box-shadow: none;
            cursor: not-allowed;
        }

        /* Swipe feedback (simple overlay) */
        .swipe-feedback {
            position: absolute; /* Positioned relative to the flashcard-container */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8); /* Initial small state */
            font-size: 5em;  /* Adjust size of check/cross */
            color: white;
            /* background-color: rgba(0,0,0,0.5); /* Default, overridden by .correct/.wrong */
            padding: 20px;
            border-radius: 50%; /* Make it circular */
            opacity: 0;      /* Hidden by default */
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            pointer-events: none; /* So it doesn't interfere with card tap/swipe */
            z-index: 10; /* Ensure it's above the flashcard */
        }
        .swipe-feedback.show {
            opacity: 0.8; /* Visible */
            transform: translate(-50%, -50%) scale(1); /* Scale to full size */
        }
        .swipe-feedback.correct {
            background-color: rgba(40, 167, 69, 0.75); /* Greenish */
        }
        .swipe-feedback.wrong {
            background-color: rgba(220, 53, 69, 0.75); /* Reddish */
        }

        #loading-indicator { /* Should be fine, centered by app-container */ }
    </style>
</head>
<body>
<div class="app-container">
    <div class="stats-bar">
        <span>Correct: <span id="correct-count" class="stat-value stat-correct-value">0</span></span>
        <span>Wrong: <span id="wrong-count" class="stat-value stat-wrong-value">0</span></span>
        <span>Completion: <span id="completion-percentage" class="stat-value stat-completion-value">0%</span></span>
    </div>

    <div id="loading-indicator">Loading words...</div>

    <div class="flashcard-container" style="display: none;">
        <div class="flashcard" id="flashcard">
            <div class="card-face card-front">
                <div id="sanskrit-word" class="sanskrit-word"></div>
                <div id="phonetic-1" class="pronunciation"></div>
                <div id="phonetic-2" class="pronunciation"></div>
                <div id="card-counter-front" class="card-counter"></div>
            </div>
            <div class="card-face card-back">
                <div id="english-meaning" class="english-meaning"></div>
                <div id="card-counter-back" class="card-counter"></div>
            </div>
        </div>
        <!-- Swipe Feedback Overlay is here -->
        <div id="swipe-feedback-overlay" class="swipe-feedback"></div>
    </div>

    <!-- HTML Order for buttons: Prev, Reset, Next -->
    <div class="controls">
        <button id="prev-button">Prev</button>
        <button id="reset-button" class="reset-button">Reset</button>
        <button id="next-button">Next</button>
    </div>
</div>

<script>
    // --- JAVASCRIPT REMAINS THE SAME ---
    let allWords = [];
    let currentDeck = [];
    let currentIndex = 0;
    let correctCount = 0;
    let wrongCount = 0;

    const flashcardElement = document.getElementById('flashcard');
    const sanskritWordEl = document.getElementById('sanskrit-word');
    const phonetic1El = document.getElementById('phonetic-1');
    const phonetic2El = document.getElementById('phonetic-2');
    const englishMeaningEl = document.getElementById('english-meaning');
    const cardCounterFrontEl = document.getElementById('card-counter-front');
    const cardCounterBackEl = document.getElementById('card-counter-back');
    const prevButton = document.getElementById('prev-button');
    const nextButton = document.getElementById('next-button');
    const resetButton = document.getElementById('reset-button');
    const correctCountValEl = document.getElementById('correct-count');
    const wrongCountValEl = document.getElementById('wrong-count');
    const completionPercentageValEl = document.getElementById('completion-percentage');
    const loadingIndicator = document.getElementById('loading-indicator');
    const flashcardContainer = document.querySelector('.flashcard-container');
    const swipeFeedbackOverlay = document.getElementById('swipe-feedback-overlay'); // Ensured this is selected

    // console.log("SanskritFlashcards JS: Script start.");

    function initializeApp() { /* ... same ... */
        loadingIndicator.style.display = 'block'; flashcardContainer.style.display = 'none';
        correctCountValEl.textContent = '0'; wrongCountValEl.textContent = '0'; completionPercentageValEl.textContent = '0%';
        if (typeof AndroidInterface !== 'undefined' && typeof AndroidInterface.getSanskritWords === 'function') {
            try {
                const rawData = AndroidInterface.getSanskritWords();
                if (!rawData || rawData.trim() === "") { loadingIndicator.textContent = "Error: Empty data."; return; }
                allWords = parseData(rawData);
                if (allWords.length === 0) { loadingIndicator.textContent = "No words found."; return; }
                resetStatsAndDeck(); updateDisplay();
                loadingIndicator.style.display = 'none'; flashcardContainer.style.display = 'flex';
            } catch (e) { loadingIndicator.textContent = "Init Error."; console.error("JS Init Error:", e); }
        } else { loadingIndicator.textContent = "Error: AndroidInterface missing."; }
        setupEventListeners();
    }

    function parseData(dataString) { /* ... same as previous correct version ... */
        const processedDataString = dataString.replace(/\\n/g, '\n'); const linesArray = processedDataString.split(/\r?\n/);
        let malformedLinesSkipped = 0; let parsedWords = linesArray.map(l => l.trim()).filter(l => l.length > 0 && !l.startsWith("#"))
            .map((line, index) => { const parts = line.split('\t'); let s = "", p = "", i = "", e = "", c = 0;
                if (parts.length > c) s = parts[c++].trim(); while(parts.length > c && parts[c].trim() === "") c++; if (parts.length > c) p = parts[c++].trim();
                while(parts.length > c && parts[c].trim() === "") c++; if (parts.length > c) i = parts[c++].trim();
                while(parts.length > c && parts[c].trim() === "") c++; if (parts.length > c) e = parts[c].trim();
                if (s && e) return { id: index, sanskrit: s, phonetic: p, iast: i, english: e, status: 'unseen' };
                malformedLinesSkipped++; return null;
            }).filter(w => w !== null);
        console.log(`Parse: Lines ${linesArray.length}, Malformed ${malformedLinesSkipped}, Parsed ${parsedWords.length}`); return parsedWords;
    }
    function shuffleArray(array) { /* ... same ... */ for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } }
    function resetStatsAndDeck() { /* ... same ... */ correctCount = 0; wrongCount = 0; currentIndex = 0; if (allWords && allWords.length > 0) { allWords.forEach(w => w.status = 'unseen'); currentDeck = [...allWords]; shuffleArray(currentDeck); } else { currentDeck = []; } flashcardElement.classList.remove('is-flipped'); updateStatsDisplay(); }
    function updateDisplay() { /* ... same ... */ if (!currentDeck || currentDeck.length === 0) { sanskritWordEl.textContent = "Finished!"; phonetic1El.textContent = "No words."; phonetic2El.textContent = ""; englishMeaningEl.textContent = "Well done!"; cardCounterFrontEl.textContent = "0 of 0"; cardCounterBackEl.textContent = "0 of 0"; prevButton.disabled = true; nextButton.disabled = true; updateStatsDisplay(); return; } const word = currentDeck[currentIndex]; if (!word) { sanskritWordEl.textContent = "Error!"; return; } sanskritWordEl.textContent = word.sanskrit; phonetic1El.textContent = word.phonetic; phonetic2El.textContent = word.iast; englishMeaningEl.textContent = word.english; const txt = `${currentIndex + 1} of ${currentDeck.length}`; cardCounterFrontEl.textContent = txt; cardCounterBackEl.textContent = txt; prevButton.disabled = currentIndex === 0; nextButton.disabled = currentIndex === currentDeck.length - 1; updateStatsDisplay(); }
    function updateStatsDisplay() { /* ... same, targets new value spans ... */ correctCountValEl.textContent = correctCount; wrongCountValEl.textContent = wrongCount; const total = allWords ? allWords.length : 0; let comp = 0; if (total > 0) { const seen = allWords.filter(w => w.status !== 'unseen').length; comp = Math.round((seen / total) * 100); } completionPercentageValEl.textContent = `${comp}%`; }
    function flipCard() { /* ... same ... */ flashcardElement.classList.toggle('is-flipped'); }
    function showNextCard() { /* ... same ... */ if (currentIndex < currentDeck.length - 1) { currentIndex++; flashcardElement.classList.remove('is-flipped'); updateDisplay(); } }
    function showPrevCard() { /* ... same ... */ if (currentIndex > 0) { currentIndex--; flashcardElement.classList.remove('is-flipped'); updateDisplay(); } }
    function handleReset() { /* ... same ... */ if (confirm("Reset progress?")) { resetStatsAndDeck(); updateDisplay(); } }
    let touchstartX = 0; let touchendX = 0; const swipeThreshold = 50;
    function handleTouchStart(event) { if (event.changedTouches.length > 0) touchstartX = event.changedTouches[0].screenX; }
    function handleTouchEnd(event) { if (event.changedTouches.length > 0) { touchendX = event.changedTouches[0].screenX; handleSwipeGesture(); } }
    function handleSwipeGesture() { /* ... same ... */ if (currentDeck.length === 0 || touchstartX === 0) return; const dX = touchendX - touchstartX; if (Math.abs(dX) < swipeThreshold) { touchstartX=0; touchendX=0; return; } let act = false; if (dX < -swipeThreshold) { markCard('wrong'); act=true; } else if (dX > swipeThreshold) { markCard('correct'); act=true; } touchstartX=0; touchendX=0; if (act) { setTimeout(() => { showNextCard(); }, 500); } }
    function markCard(status) { /* ... same ... */ if (currentDeck.length === 0) return; const word = currentDeck[currentIndex]; if (!word) return; if (status === 'correct') { correctCount++; showSwipeFeedback(true); } else if (status === 'wrong') { wrongCount++; showSwipeFeedback(false); } const master = allWords.find(w => w.id === word.id); if (master) master.status = status; word.status = status; updateStatsDisplay(); if (typeof AndroidInterface !== 'undefined' && AndroidInterface.performHapticFeedback) AndroidInterface.performHapticFeedback(); }
    function showSwipeFeedback(isCorrect) { /* ... same ... */ swipeFeedbackOverlay.textContent = isCorrect ? '✓' : '✗'; swipeFeedbackOverlay.className = 'swipe-feedback show ' + (isCorrect ? 'correct' : 'wrong'); setTimeout(() => { swipeFeedbackOverlay.className = 'swipe-feedback'; }, 600); }
    function setupEventListeners() { /* ... same ... */ flashcardElement.addEventListener('click', flipCard); prevButton.addEventListener('click', showPrevCard); nextButton.addEventListener('click', showNextCard); resetButton.addEventListener('click', handleReset); flashcardContainer.addEventListener('touchstart', handleTouchStart, { passive: true }); flashcardContainer.addEventListener('touchend', handleTouchEnd, { passive: true }); }
    document.addEventListener('DOMContentLoaded', () => { initializeApp(); });
</script>
</body>
</html>

