<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sanskrit Flashcards</title>
    <style>
        /* THIS IS THE CSS FROM BEFORE THE VERY LAST UI-FOCUSED CHANGES */
        /* It might result in the narrow card, but the goal here is to check JS execution */
        :root {
            --card-background: #fff;
            --card-border: #ddd;
            --text-color: #333;
            --accent-color: #007bff;
            --correct-color: #28a745;
            --wrong-color: #dc3545;
            --button-text-color: #fff;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between; /* Push controls to bottom */
            min-height: 100vh;
            margin: 0;
            background-color: #f0f2f5;
            color: var(--text-color);
            padding: 10px;
            box-sizing: border-box;
            overflow: hidden;
        }
        .app-container {
            width: 100%;
            max-width: 500px;
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            justify-content: center;
        }
        .stats-bar {
            width: 100%;
            padding: 8px 0;
            text-align: center;
            font-size: 0.9em;
            color: #555;
            border-bottom: 1px solid #e0e0e0;
            margin-bottom: 15px;
            white-space: nowrap;
            overflow-x: auto;
        }
        .stats-bar span { margin: 0 8px; }

        .flashcard-container {
            perspective: 1000px;
            width: 100%;
            min-height: 250px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .flashcard {
            width: 90%;
            max-width: 400px;
            min-height: 250px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            cursor: pointer;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        .flashcard.is-flipped {
            transform: rotateY(180deg);
        }
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            box-sizing: border-box;
            border-radius: 12px;
            background-color: var(--card-background);
            border: 1px solid var(--card-border);
            text-align: center;
        }
        .card-front { }
        .card-back {
            transform: rotateY(180deg);
        }
        .sanskrit-word {
            font-size: 2.8em;
            margin-bottom: 15px;
            color: var(--text-color);
        }
        .pronunciation {
            font-size: 1.1em;
            line-height: 1.5;
            color: #444;
        }
        .english-meaning {
            font-size: 2em;
            color: var(--text-color);
        }
        .card-counter {
            font-size: 0.9em;
            color: #777;
            position: absolute;
            bottom: 10px;
            left: 0;
            right: 0;
            text-align: center;
        }

        .controls {
            width: 100%;
            max-width: 500px;
            display: flex;
            justify-content: space-around;
            padding: 15px 0;
            background-color: #f0f2f5;
            border-top: 1px solid #e0e0e0;
        }
        .controls button {
            padding: 12px 20px;
            font-size: 1.1em;
            background-color: var(--accent-color);
            color: var(--button-text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            min-width: 100px;
            transition: background-color 0.2s;
        }
        .controls button:hover {
            background-color: #0056b3;
        }
        .controls button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .reset-button {
            background-color: #6c757d;
        }
        .reset-button:hover {
            background-color: #5a6268;
        }

        .swipe-feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            font-size: 5em;
            color: white;
            padding: 20px;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none;
        }
        .swipe-feedback.show {
            opacity: 0.8;
            transform: translate(-50%, -50%) scale(1);
        }
        .swipe-feedback.correct { background-color: rgba(40, 167, 69, 0.7); }
        .swipe-feedback.wrong { background-color: rgba(220, 53, 69, 0.7); }

        #loading-indicator {
            font-size: 1.2em;
            text-align: center;
            margin-top: 30px;
            color: #333;
        }
    </style>
</head>
<body>
<div class="stats-bar">
    <span id="correct-count">Correct: 0</span>
    <span id="wrong-count">Wrong: 0</span>
    <span id="completion-percentage">Completion: 0%</span>
</div>

<div class="app-container">
    <div id="loading-indicator">Loading words...</div>
    <div class="flashcard-container" style="display: none;">
        <div class="flashcard" id="flashcard">
            <div class="card-face card-front">
                <div id="sanskrit-word" class="sanskrit-word"></div>
                <div id="phonetic-1" class="pronunciation"></div>
                <div id="phonetic-2" class="pronunciation"></div>
                <div id="card-counter-front" class="card-counter"></div>
            </div>
            <div class="card-face card-back">
                <div id="english-meaning" class="english-meaning"></div>
                <div id="card-counter-back" class="card-counter"></div>
            </div>
        </div>
        <div id="swipe-feedback-overlay" class="swipe-feedback"></div>
    </div>
</div>

<div class="controls">
    <button id="prev-button">Prev</button>
    <button id="next-button">Next</button>
    <button id="reset-button" class="reset-button">Reset</button>
</div>

<script>
    let allWords = [];
    let currentDeck = [];
    let currentIndex = 0;
    let correctCount = 0;
    let wrongCount = 0;

    // DOM Elements
    const flashcardElement = document.getElementById('flashcard');
    const sanskritWordEl = document.getElementById('sanskrit-word');
    const phonetic1El = document.getElementById('phonetic-1');
    const phonetic2El = document.getElementById('phonetic-2');
    const englishMeaningEl = document.getElementById('english-meaning');
    const cardCounterFrontEl = document.getElementById('card-counter-front');
    const cardCounterBackEl = document.getElementById('card-counter-back');
    const prevButton = document.getElementById('prev-button');
    const nextButton = document.getElementById('next-button');
    const resetButton = document.getElementById('reset-button');
    const correctCountEl = document.getElementById('correct-count');
    const wrongCountEl = document.getElementById('wrong-count');
    const completionPercentageEl = document.getElementById('completion-percentage');
    const loadingIndicator = document.getElementById('loading-indicator');
    const flashcardContainer = document.querySelector('.flashcard-container');
    const swipeFeedbackOverlay = document.getElementById('swipe-feedback-overlay');

    console.log("SanskritFlashcards JS: Script start. DOM elements selected.");

    function initializeApp() {
        console.log("SanskritFlashcards JS: initializeApp() called.");
        loadingIndicator.style.display = 'block';
        flashcardContainer.style.display = 'none';
        correctCountEl.textContent = `Correct: 0`;
        wrongCountEl.textContent = `Wrong: 0`;
        completionPercentageEl.textContent = `Completion: 0%`;

        if (typeof AndroidInterface !== 'undefined' && typeof AndroidInterface.getSanskritWords === 'function') {
            console.log("SanskritFlashcards JS: AndroidInterface.getSanskritWords found. Calling it...");
            try {
                const rawDataFromAndroid = AndroidInterface.getSanskritWords();
                console.log("SanskritFlashcards JS: Received rawData from Android. Length:", rawDataFromAndroid ? rawDataFromAndroid.length : 'null');

                if (!rawDataFromAndroid) {
                    console.error("SanskritFlashcards JS: rawData from Android is null or undefined!");
                    loadingIndicator.textContent = "Error: Null data from app.";
                    return;
                }
                 if (rawDataFromAndroid.trim() === "") {
                    console.error("SanskritFlashcards JS: rawData from Android is empty or whitespace.");
                    loadingIndicator.textContent = "Error: Empty data from app.";
                    return;
                }
                console.log("SanskritFlashcards JS: rawData snippet (first 500 chars):", rawDataFromAndroid.substring(0, 500));

                allWords = parseData(rawDataFromAndroid);
                console.log(`SanskritFlashcards JS: parseData() completed. Total words parsed into allWords: ${allWords.length}`);

                if (allWords.length === 0) {
                    console.warn("SanskritFlashcards JS: No words available after parsing. Check data format or parseData logic. Raw data length was:", rawDataFromAndroid.length);
                    loadingIndicator.textContent = "No words found after parsing. Please check the data source and console logs.";
                    return;
                }

                resetStatsAndDeck();
                console.log(`SanskritFlashcards JS: Deck reset and shuffled. currentDeck length: ${currentDeck.length}`);

                updateDisplay();
                console.log("SanskritFlashcards JS: Initial display updated.");

                // This is the critical part for your "Stuck on loading" issue
                console.log("SanskritFlashcards JS: About to hide loading indicator and show flashcard container.");
                loadingIndicator.style.display = 'none';
                flashcardContainer.style.display = 'flex';
                console.log("SanskritFlashcards JS: UI should now be visible.");

            } catch (e) {
                console.error("SanskritFlashcards JS: Error during AndroidInterface interaction or subsequent processing:", e);
                loadingIndicator.textContent = "Initialization Error. Check console logs for details.";
                // Make sure we log the error object itself for more details
                console.error("SanskritFlashcards JS: The actual error object is:", e);
            }
        } else {
            loadingIndicator.textContent = "Error: AndroidInterface not found. Cannot load words.";
            console.warn("SanskritFlashcards JS: AndroidInterface or getSanskritWords method not found.");
        }
        setupEventListeners();
        console.log("SanskritFlashcards JS: Event listeners set up.");
    }

    function parseData(dataString) {
        console.log("-------------------- PARSE DATA START --------------------");
        console.log("parseData: Input dataString length (from Android):", dataString.length);

        const processedDataString = dataString.replace(/\\n/g, '\n'); // THE FIX for literal \n
        console.log("parseData: Processed dataString length (after replacing '\\\\n' with '\\n'):", processedDataString.length);

        if (processedDataString.length < 500) {
            console.log("parseData: Full processedDataString:", processedDataString);
        } else {
            console.log("parseData: Processed dataString (first 250 chars):", processedDataString.substring(0, 250));
            console.log("parseData: Processed dataString (last 250 chars):", processedDataString.substring(processedDataString.length - 250));
        }

        const linesArray = processedDataString.split(/\r?\n/);
        console.log(`parseData: Split processedDataString into ${linesArray.length} lines (using /\\r?\\n/).`);
        if (linesArray.length <= 1 && processedDataString.includes("\n")) {
             console.warn("parseData: Only one line after split, but processed string *does* contain actual newline characters. This is unexpected if replacement worked.");
        }

        let validLinesFound = 0;
        let malformedLinesSkipped = 0;
        let commentOrEmptyLinesSkipped = 0;

        const parsedWords = linesArray
            .map((line, index) => ({ originalLine: line, originalIndex: index, trimmedLine: line.trim() }))
            .filter(item => {
                if (item.trimmedLine.length === 0 || item.trimmedLine.startsWith("#")) {
                    commentOrEmptyLinesSkipped++;
                    return false;
                }
                return true;
            })
            .map((item, processedIndex) => {
                const line = item.trimmedLine;
                const parts = line.split('\t');
                if (parts.length >= 4) {
                    validLinesFound++;
                    return {
                        id: item.originalIndex,
                        sanskrit: parts[0].trim(),
                        phonetic: parts[1].trim(),
                        iast: parts[2].trim(),
                        english: parts[3].trim(),
                        status: 'unseen'
                    };
                } else {
                    malformedLinesSkipped++;
                    console.warn(`parseData Map: MALFORMED Line #${item.originalIndex + 1}. Expected >= 4 tab-separated parts, got ${parts.length}. Line content: "${line}". Parts found:`, JSON.stringify(parts));
                    return null;
                }
            }).filter(word => word !== null);

        console.log(`parseData: Summary - Lines in input after processing: ${linesArray.length}, Comment/Empty lines skipped: ${commentOrEmptyLinesSkipped}, Malformed lines (due to parts count): ${malformedLinesSkipped}, Successfully parsed words: ${parsedWords.length} (from ${validLinesFound} validly structured lines).`);
        console.log("-------------------- PARSE DATA END ----------------------");
        return parsedWords;
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function resetStatsAndDeck() {
        correctCount = 0;
        wrongCount = 0;
        currentIndex = 0;
        if (allWords && allWords.length > 0) {
            allWords.forEach(word => word.status = 'unseen');
            currentDeck = [...allWords];
            shuffleArray(currentDeck);
        } else {
            currentDeck = [];
        }
        flashcardElement.classList.remove('is-flipped');
        console.log(`SanskritFlashcards JS: resetStatsAndDeck() - Stats reset. currentDeck created/reset with ${currentDeck.length} words and shuffled.`);
        updateStatsDisplay();
    }

    function updateDisplay() {
        if (!currentDeck || currentDeck.length === 0) {
            sanskritWordEl.textContent = "Finished!";
            phonetic1El.textContent = (allWords && allWords.length > 0) ? "" : "No words loaded.";
            phonetic2El.textContent = "";
            englishMeaningEl.textContent = (allWords && allWords.length > 0) ? "Well done!" : "Please check data source.";
            cardCounterFrontEl.textContent = "0 of 0";
            cardCounterBackEl.textContent = "0 of 0";
            prevButton.disabled = true;
            nextButton.disabled = true;
            updateStatsDisplay();
            return;
        }

        const word = currentDeck[currentIndex];
        if (!word) {
            console.error("SanskritFlashcards JS: updateDisplay() - Word is undefined at currentIndex", currentIndex, ". Deck:", currentDeck);
            sanskritWordEl.textContent = "Error!";
            phonetic1El.textContent = "";
            phonetic2El.textContent = "";
            englishMeaningEl.textContent = "Could not load card.";
            return;
        }

        sanskritWordEl.textContent = word.sanskrit;
        phonetic1El.textContent = word.phonetic;
        phonetic2El.textContent = word.iast;
        englishMeaningEl.textContent = word.english;

        const counterText = `${currentIndex + 1} of ${currentDeck.length}`;
        cardCounterFrontEl.textContent = counterText;
        cardCounterBackEl.textContent = counterText;

        prevButton.disabled = currentIndex === 0;
        nextButton.disabled = currentIndex === currentDeck.length - 1;
        updateStatsDisplay();
    }

    function updateStatsDisplay() {
        correctCountEl.textContent = `Correct: ${correctCount}`;
        wrongCountEl.textContent = `Wrong: ${wrongCount}`;
        const totalSourceWords = allWords ? allWords.length : 0;
        let completion = 0;
        if (totalSourceWords > 0) {
             const uniqueSeenCount = allWords.filter(w => w.status !== 'unseen').length;
             completion = Math.round((uniqueSeenCount / totalSourceWords) * 100);
        }
        completionPercentageEl.textContent = `Completion: ${completion}%`;
    }

    function flipCard() {
        flashcardElement.classList.toggle('is-flipped');
    }

    function showNextCard() {
        if (currentIndex < currentDeck.length - 1) {
            currentIndex++;
            flashcardElement.classList.remove('is-flipped');
            updateDisplay();
        } else {
            console.log("SanskritFlashcards JS: showNextCard() - End of current deck.");
        }
    }

    function showPrevCard() {
        if (currentIndex > 0) {
            currentIndex--;
            flashcardElement.classList.remove('is-flipped');
            updateDisplay();
        }
    }

    function handleReset() {
        console.log("SanskritFlashcards JS: handleReset() button clicked.");
        if (confirm("Are you sure you want to reset all progress and start over?")) {
            resetStatsAndDeck();
            updateDisplay();
            console.log("SanskritFlashcards JS: Progress reset by user.");
        } else {
            console.log("SanskritFlashcards JS: User cancelled reset.");
        }
    }

    let touchstartX = 0;
    let touchendX = 0;
    const swipeThreshold = 50;

    function handleTouchStart(event) {
        if (event.changedTouches.length > 0) {
            touchstartX = event.changedTouches[0].screenX;
        }
    }

    function handleTouchEnd(event) {
        if (event.changedTouches.length > 0) {
            touchendX = event.changedTouches[0].screenX;
            handleSwipeGesture();
        }
    }

    function handleSwipeGesture() {
        if (currentDeck.length === 0 || touchstartX === 0) return;

        const deltaX = touchendX - touchstartX;
        if (Math.abs(deltaX) < swipeThreshold) {
            touchstartX = 0; touchendX = 0;
            return;
        }

        let actionTaken = false;
        if (deltaX < -swipeThreshold) {
            markCard('wrong');
            actionTaken = true;
        } else if (deltaX > swipeThreshold) {
            markCard('correct');
            actionTaken = true;
        }

        touchstartX = 0;
        touchendX = 0;

        if (actionTaken) {
            setTimeout(() => {
                showNextCard();
            }, 500);
        }
    }

    function markCard(status) {
        if (currentDeck.length === 0) return;
        const currentWordData = currentDeck[currentIndex];
        if (!currentWordData) {
            console.error("SanskritFlashcards JS: markCard() - currentWordData is undefined at index", currentIndex);
            return;
        }
        console.log(`SanskritFlashcards JS: markCard() - Card '${currentWordData.sanskrit}' as ${status}.`);

        if (status === 'correct') {
            correctCount++;
            showSwipeFeedback(true);
        } else if (status === 'wrong') {
            wrongCount++;
            showSwipeFeedback(false);
        }

        const masterWord = allWords.find(w => w.id === currentWordData.id);
        if (masterWord) {
            masterWord.status = status;
        } else {
             console.warn(`SanskritFlashcards JS: markCard() - Could not find master word for ID ${currentWordData.id} to update status.`);
        }
        currentWordData.status = status;

        updateStatsDisplay();

        if (typeof AndroidInterface !== 'undefined' && AndroidInterface.performHapticFeedback) {
             AndroidInterface.performHapticFeedback();
        }
    }

    function showSwipeFeedback(isCorrect) {
        swipeFeedbackOverlay.textContent = isCorrect ? '✓' : '✗';
        swipeFeedbackOverlay.className = 'swipe-feedback show ' + (isCorrect ? 'correct' : 'wrong');
        setTimeout(() => {
            swipeFeedbackOverlay.className = 'swipe-feedback';
        }, 600);
    }

    function setupEventListeners() {
        flashcardElement.addEventListener('click', flipCard);
        prevButton.addEventListener('click', showPrevCard);
        nextButton.addEventListener('click', showNextCard);
        resetButton.addEventListener('click', handleReset);
        flashcardContainer.addEventListener('touchstart', handleTouchStart, { passive: true });
        flashcardContainer.addEventListener('touchend', handleTouchEnd, { passive: true });
        console.log("SanskritFlashcards JS: Event listeners are set up.");
    }

    document.addEventListener('DOMContentLoaded', () => {
        console.log("SanskritFlashcards JS: DOMContentLoaded event fired. Initializing app...");
        initializeApp();
    });

</script>
</body>
</html>
